@schema ./quiz-questions.schema.styx

/// Quiz questions for the Styx primer
/// Organized by learning progression
questions {
    //==========================================================================
    // Section 1: Basics - key-value pairs, objects, sequences
    //==========================================================================
    basics-json-to-styx {
        question <<DOC,markdown
            Are these two documents equivalent?

            ```compare
            /// json
            {"name": "Alice"}
            /// styx
            name: "Alice"
            ```
            DOC
        options (
            {text "Yes", help "Look carefully at the key in the Styx version"}
            {text "No", correct true}
        )
        explanation <<DOC,markdown
            The colon is part of the key! In Styx, `name: "Alice"` parses as:

            - key: `name:` (bare scalar including the colon)
            - value: `Alice`

            The equivalent Styx would be:

            ```styx
            name Alice
            ```
            DOC
    }
    bare-scalar-path {
        question <<DOC,markdown
            Are these equivalent?

            ```compare
            /// json
            {"path": "/usr/local/bin"}
            /// styx
            path /usr/local/bin
            ```
            DOC
        options (
            {text "Yes", correct true}
            {text "No", help "Slashes are fine in bare scalars"}
        )
        explanation <<DOC,markdown
            Paths work as bare scalars. Slashes don't have special meaning in Styx.
            DOC
    }
    bare-scalar-url {
        question <<DOC,markdown
            Are these equivalent?

            ```compare
            /// json
            {"url": "https://example.org/path?q=1"}
            /// styx
            url https://example.org/path?q=1
            ```
            DOC
        options (
            {text "Yes", correct true}
            {text "No", help "Colons, slashes, question marks, equals signs - all fine"}
        )
        explanation <<DOC,markdown
            URLs work as bare scalars. The only characters that terminate a bare scalar are whitespace, `{`, `}`, `(`, `)`, `,`, `"`, and `>`.
            DOC
    }
    bare-scalar-space {
        question <<DOC,markdown
            Are these equivalent?

            ```compare
            /// json
            {"greeting": "hello world"}
            /// styx
            greeting hello world
            ```
            DOC
        options (
            {text "Yes", help "Spaces terminate bare scalars"}
            {text "No", correct true}
        )
        explanation <<DOC,markdown
            Spaces terminate bare scalars. The Styx has three atoms (`greeting`, `hello`, `world`) — that's a parse error.

            Use quotes for values with spaces: `greeting "hello world"`
            DOC
    }
    bare-scalar-comma {
        question <<DOC,markdown
            Are these equivalent?

            ```compare
            /// json
            {"list": "a,b,c"}
            /// styx
            list a,b,c
            ```
            DOC
        options (
            {text "Yes", help "Commas terminate bare scalars"}
            {text "No", correct true}
        )
        explanation <<DOC,markdown
            Commas terminate bare scalars. The Styx parses as key `list`, value `a`, then `,b,c` — a parse error.

            Use quotes: `list "a,b,c"`
            DOC
    }
    basics-sequence-syntax {
        question <<DOC,markdown
            Are these equivalent?

            ```compare
            /// json
            {"key": ["value"]}
            /// styx
            key [value]
            ```
            DOC
        options (
            {text "Yes", help "Square brackets aren't special in Styx"}
            {text "No", correct true}
        )
        explanation <<DOC,markdown
            Square brackets have no special meaning in Styx, so that doc is equivalent to:

            ```json
            {"key": "[value]"}
            ```

            The equivalent styx would've been:

            ```styx
            key (value)
            ```
            DOC
    }
    basics-comma-sequence {
        question <<DOC,markdown
            Are these equivalent?

            ```compare
            /// json
            {"items": ["a", "b", "c"]}
            /// styx
            items (a, b, c)
            ```
            DOC
        options (
            {text "Yes", help "Sequences don't use commas"}
            {text "No", correct true}
        )
        explanation <<DOC,markdown
            Sequences are whitespace-separated. Commas are a parse error.

            The equivalent Styx is:

            ```styx
            items (a b c)
            ```
            DOC
    }
    basics-mixing-separators {
        question <<DOC,markdown
            Are these equivalent?

            ```compare
            /// json
            {"a": 1, "b": 2, "c": 3}
            /// styx
            {a 1, b 2
            c 3}
            ```
            DOC
        options (
            {text "Yes", help "Objects must use one separator style consistently"}
            {text "No", correct true}
        )
        explanation <<DOC,markdown
            Objects must use either commas:

            ```styx
            {a 1, b 2, c 3}
            ```

            or newlines:

            ```styx
            {
                a 1
                b 2
                c 3
            }
            ```

            but never both.
            DOC
    }
    basics-duplicate-keys {
        question <<DOC,markdown
            Is this valid Styx?

            ```styx
            name Alice
            name Bob
            ```
            DOC
        options (
            {text "Valid - Bob overwrites Alice", help "Styx doesn't allow duplicate keys"}
            {text "Valid - creates a list of names", help "Styx doesn't auto-convert to arrays"}
            {text "Invalid", correct true}
        )
        explanation <<DOC,markdown
            Objects cannot have duplicate keys. Each key must be unique within its object.
            DOC
    }
    //==========================================================================
    // Section 2: Scalars are just text
    //==========================================================================
    scalars-number {
        question <<DOC,markdown
            In this document, what type is `42`?

            ```styx
            answer 42
            ```
            DOC
        options (
            {text "Integer", help "Styx scalars don't have inherent types"}
            {text "Number", help "Styx scalars don't have inherent types"}
            {text "Neither", correct true}
        )
        explanation <<DOC,markdown
            Scalars are untyped text. `42` is not inherently a number any more than `hello` is inherently a string.

            Types matter at two points:
            - Schema validation
            - Deserialization into a typed language
            DOC
    }
    //==========================================================================
    // Section 3: Tags and the two dimensions
    //==========================================================================
    tags-two-dimensions {
        question <<DOC,markdown
            Every Styx value has two parts: a **tag** and a **payload**.

            What are the tag and payload of `hello`?

            ```styx
            greeting hello
            ```
            DOC
        options (
            {text "`tag=hello`, `payload=@`", help "The word itself is the payload, not the tag"}
            {text "`tag=@`, `payload=hello`", correct true}
            {text "No tag - it's just a plain value", help "Every value has a tag; it defaults to `@`"}
        )
        explanation <<DOC,markdown
            A bare scalar like `hello` has:
            - **tag**: `@` (empty/default)
            - **payload**: `hello`

            Every Styx value has both parts. When you don't write a tag, it's implicitly `@`.
            DOC
    }
    tags-explicit {
        question <<DOC,markdown
            What are the tag and payload of `@rgb(255 128 0)`?

            ```styx
            color @rgb(255 128 0)
            ```
            DOC
        options (
            {text "`tag=rgb`, `payload=(255 128 0)`", correct true}
            {text "`tag=@`, `payload=rgb(255 128 0)`", help "The `@` starts a tag name"}
            {text "`tag=color`, `payload=rgb`", help "`color` is the key, not part of the value"}
        )
        explanation <<DOC,markdown
            `@rgb(255 128 0)` has:
            - **tag**: `rgb`
            - **payload**: `(255 128 0)` (a sequence)

            Tags attach semantic meaning - useful for enums where the tag selects a variant.
            DOC
    }
    tags-unit-payload {
        question <<DOC,markdown
            What are the tag and payload of `@pending`?

            ```styx
            status @pending
            ```
            DOC
        options (
            {text "`tag=pending`, `payload=@` (unit)", correct true}
            {text "`tag=@`, `payload=pending`", help "The `@` before `pending` makes `pending` the tag"}
            {text "`tag=pending`, no payload", help "Every value has a payload; it defaults to `@`"}
        )
        explanation <<DOC,markdown
            `@pending` has:
            - **tag**: `pending`
            - **payload**: `@` (unit, implied)

            When a tag has no explicit payload, it defaults to `@`. The canonical form is `@pending@`.
            DOC
    }
    tags-space-matters {
        question <<DOC,markdown
            Are those two lines the same?

            ```styx
            key @tag()
            // vs
            key @tag ()
            ```
            DOC
        options (
            {text "Yes, they're the same", help "Space between tag and payload is significant"}
            {text "They're both valid but different", help "Count the atoms on line b"}
            {text "One of them is invalid", correct true}
        )
        explanation <<DOC,markdown
            First line: key `key`, value `@tag()` (tagged empty sequence). Two atoms, valid.

            Second line: three atoms: `key`, `@tag`, `()`. Entries can only have two atoms (key and value).
            DOC
    }
    tags-standalone-vs-payload {
        question <<DOC,markdown
            Are those two lines the same?

            ```styx
            @tag()
            // vs
            @tag ()
            ```
            DOC
        options (
            {text "Yes they're the same", help "Space between tag and payload is significant"}
            {text "They're both valid but different"}
            {text "One of them is invalid", help "Both are valid Styx values", correct true}
        )
        explanation <<DOC,markdown
            The first one is an error: it's in object context, and sequences `()`
            (tagged or not) cannot be used as keys.

            The second is fine: it's using a tagged unit (canonical form `@tag@`)
            as a key, and the value is an empty sequence.
            DOC
    }
    tags-on-objects {
        question <<DOC,markdown
            Is this valid Styx?

            ```styx
            result @error{code 404, message "Not found"}
            ```
            DOC
        options (
            {text "Valid", correct true}
            {text "Invalid", help "Tags can attach to any payload type"}
        )
        explanation <<DOC,markdown
            Tags can have any payload: scalars, sequences, or objects.

            This maps to Rust-style enums:
            ```rust
            enum Result {
                Ok(Value),
                Error { code: u32, message: String },
            }
            ```
            DOC
    }
    //==========================================================================
    // Section 4: Unit and elision
    //==========================================================================
    unit-what-is {
        question <<DOC,markdown
            What does `@` by itself represent?

            ```styx
            nothing @
            ```
            DOC
        options (
            {text "An empty string", help "Unit is distinct from empty string"}
            {text "A parse error - @ needs a tag name", help "@ alone is valid"}
            {text "The unit value (like null)", correct true}
        )
        explanation <<DOC,markdown
            `@` is the unit value - similar to `null` / `None` etc..

            Fun fact: `@` is shorthand for `@@` (empty tag with unit payload). An empty tag degenerates to `@`, and a missing payload defaults to `@`.
            DOC
    }
    unit-canonical {
        question <<DOC,markdown
            Which is the canonical (fully explicit) form?

            ```styx
            value @ok
            ```
            DOC
        options (
            {text "`value @ok` is already canonical", help "The payload is implied"}
            {text "`value @ok@`", correct true}
            {text "`value ok`", help "That removes the tag entirely"}
        )
        explanation <<DOC,markdown
            When a tag has no explicit payload, it defaults to `@` (unit).

            - `@ok` — idiomatic, payload implied
            - `@ok@` — canonical, payload explicit

            Both mean: tag `ok`, payload `@` (unit).
            DOC
    }
    unit-elision-key {
        question <<DOC,markdown
            What does this mean?

            ```styx
            {enabled, debug, verbose}
            ```
            DOC
        options (
            {text "A sequence", help "Sequences use `()`, this is `{}`"}
            {text "An object", correct true}
            {text "A parse error", help "Omitting values is valid"}
        )
        explanation <<DOC,markdown
            When a key has no value, it defaults to `@` (unit). This is idiomatic for flags/options.

            Canonical form:
            ```styx
            {enabled @, debug @, verbose @}
            ```

            Idiomatic form:
            ```styx
            {enabled, debug, verbose}
            ```
            DOC
    }
    unit-sparse-sequence {
        question <<DOC,markdown
            Is this valid Styx?

            ```styx
            grid (1 2 @ @ 5)
            ```
            DOC
        options (
            {text "Valid", correct true}
            {text "Invalid", help "Unit is a value like any other"}
        )
        explanation <<DOC,markdown
            `@` is a first-class value. You can use it anywhere: as object values, sequence elements, tag payloads.

            `(1 2 @ @ 5)` is a sequence of five elements, two of which are unit.
            DOC
    }
    //==========================================================================
    // Section 5: Dotted paths and object attributes
    //==========================================================================
    dotted-paths-basic {
        question <<DOC,markdown
            What does this mean?

            ```styx
            server.host localhost
            ```
            DOC
        options (
            {text "A single key-value pair", help "Dots create nested structure"}
            {text "Nested objects", correct true}
        )
        explanation <<DOC,markdown
            Dotted keys define nested paths:

            ```styx
            server.host localhost
            ```

            Is equivalent to:

            ```styx
            server {
              host localhost
            }
            ```
            DOC
    }
    attributes-basic {
        question <<DOC,markdown
            What does `>` do here?

            ```styx
            server host>localhost port>8080
            ```
            DOC
        options (
            {text "Greater-than comparison", help "Styx doesn't have operators"}
            {text "Sets attributes", correct true}
            {text "A parse error", help "Object attribute syntax is valid"}
        )
        explanation <<DOC,markdown
            `key>value` is object attribute syntax - a compact way to attach properties.

            This is equivalent to:
            ```styx
            server {host localhost, port 8080}
            ```

            Useful when you have many keys with similar attributes.
            DOC
    }
    attributes-multiple {
        question <<DOC,markdown
            Is this valid Styx?

            ```styx
            {
                web  host>example.org   port>80
                api  host>api.example   port>8080
            }
            ```
            DOC
        options (
            {text "Valid", correct true}
            {text "Invalid", help "Keys can have multiple attributes"}
        )
        explanation <<DOC,markdown
            Keys can have multiple attributes. This creates:
            ```styx
            {
                web {host example.org, port 80}
                api {host api.example, port 8080}
            }
            ```

            Great for tabular data where alignment shows structure.
            DOC
    }
    //==========================================================================
    // Section 6: Heredocs
    //==========================================================================
    heredoc-basic {
        question <<DOC,markdown
            What does `<<CODE` introduce?

            ```styx
            script <<CODE
            echo "hello"
            CODE
            ```
            DOC
        options (
            {text "A file include", help "Styx doesn't have includes"}
            {text "A multiline string", correct true}
            {text "A parse error", help "Heredocs are valid Styx"}
        )
        explanation <<DOC,markdown
            `<<MARKER` starts a heredoc - a multiline string that ends when `MARKER` appears alone on a line.

            The delimiter can be any identifier: `<<EOF`, `<<SQL`, `<<CODE`, etc.
            DOC
    }
    heredoc-hint {
        question <<DOC,markdown
            What does `,rust` do here?

            ```styx
            source <<CODE,rust
            fn main() {}
            CODE
            ```
            DOC
        options (
            {text "Compiles the code as Rust", help "Styx doesn't execute code"}
            {text "A language hint", correct true}
            {text "A parse error", help "Language hints are valid"}
        )
        explanation <<DOC,markdown
            The `,rust` after the heredoc marker is a language hint. It doesn't affect parsing - it's metadata for editors and tools to enable syntax highlighting.

            Common hints: `,sql`, `,json`, `,markdown`, `,html`
            DOC
    }
    //==========================================================================
    // Section 7: Schemas
    //==========================================================================
    schema-doc-comments {
        question <<DOC,markdown
            What do `///` comments do in Styx?

            ```styx
            /// User's display name
            name @string
            ```
            DOC
        options (
            {text "Same as `//`", help "Triple-slash has special meaning"}
            {text "A doc comment", correct true}
            {text "A parse error", help "Doc comments are valid"}
        )
        explanation <<DOC,markdown
            `///` is a doc comment - it attaches to the next element as documentation.

            This powers editor features: hover for docs, autocomplete descriptions, etc.
            DOC
    }
    schema-types {
        question <<DOC,markdown
            In a Styx schema, what does `@seq(@string)` mean?

            ```styx
            tags @seq(@string)
            ```
            DOC
        options (
            {text "A sequence containing `@string`", help "In schemas, @ introduces type annotations"}
            {text "A sequence of strings", correct true}
            {text "A tagged value", help "Schema types use @ differently than data"}
        )
        explanation <<DOC,markdown
            In schemas, `@` prefixes type annotations:
            - `@string`, `@int`, `@float`, `@bool` - scalar types
            - `@seq(@T)` - sequence of T
            - `@map(@T)` - object with values of type T
            - `@optional(@T)` - T or absent
            - `@object{...}` - object with specific fields
            DOC
    }
    schema-validation {
        question <<DOC,markdown
            When can a Styx document be validated against a schema?
            DOC
        options (
            {text "Only at compile time", help "Styx has no compile step"}
            {text "Only at runtime in the application", help "Validation can happen anywhere"}
            {text "Anytime: CLI, editor, CI, runtime", correct true}
        )
        explanation <<DOC,markdown
            Schema validation is separate from parsing. Your document can be validated:
            - By the CLI (`styx validate`)
            - By your editor's LSP (live as you type)
            - In CI pipelines
            - At runtime when loading config

            This is one of Styx's key features - schemas are portable.
            DOC
    }
}

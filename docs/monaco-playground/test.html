<!DOCTYPE html>
<html>
<head>
  <title>Styx Monaco Grammar Tests</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1e1e1e; color: #d4d4d4; }
    .pass { color: #4ec9b0; }
    .fail { color: #f44747; }
    pre { margin: 0; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>Styx Monaco Grammar Tests</h1>
  <div id="output"></div>
  <script type="module">
    import { monaco, registerStyxLanguage } from './src/main.ts';

    registerStyxLanguage();

    const output = document.getElementById('output');
    function log(msg, isError = false) {
      const div = document.createElement('pre');
      div.className = isError ? 'fail' : '';
      div.textContent = msg;
      output.appendChild(div);
    }

    function tokenize(text) {
      const lines = text.split('\n');
      const result = monaco.editor.tokenize(text, 'styx');

      return result.map((lineTokens, lineIndex) => {
        const line = lines[lineIndex];
        const tokens = lineTokens.map((token, i) => {
          const nextOffset = lineTokens[i + 1]?.offset ?? line.length;
          return {
            offset: token.offset,
            type: token.type.replace('.styx', ''),
            text: line.slice(token.offset, nextOffset)
          };
        });
        return { line: lineIndex + 1, tokens };
      });
    }

    function test(name, input, expectations) {
      const result = tokenize(input);
      let passed = true;
      const errors = [];

      for (const exp of expectations) {
        const lineResult = result[exp.line - 1];
        if (!lineResult) {
          errors.push(`Line ${exp.line} not found`);
          passed = false;
          continue;
        }

        const token = lineResult.tokens.find(t => t.text === exp.text);
        if (!token) {
          errors.push(`Token "${exp.text}" not found on line ${exp.line}. Available: ${lineResult.tokens.map(t => `"${t.text}"=${t.type}`).join(', ')}`);
          passed = false;
          continue;
        }

        if (token.type !== exp.expectedType) {
          errors.push(`"${exp.text}" on line ${exp.line}: expected ${exp.expectedType}, got ${token.type}`);
          passed = false;
        }
      }

      if (passed) {
        log(`✓ PASS [${name}]`);
      } else {
        log(`✗ FAIL [${name}]`, true);
        errors.forEach(e => log(`    ${e}`, true));
      }
      return passed;
    }

    log('=== Styx Monaco Grammar Tests ===\n');

    test('simple entry',
      'name hello',
      [
        { line: 1, text: 'name', expectedType: 'key' },
        { line: 1, text: 'hello', expectedType: 'value' },
      ]
    );

    test('nested object',
      `server {
    host localhost
    port 8080
}`,
      [
        { line: 1, text: 'server', expectedType: 'key' },
        { line: 2, text: 'host', expectedType: 'key' },
        { line: 2, text: 'localhost', expectedType: 'value' },
        { line: 3, text: 'port', expectedType: 'key' },
        { line: 3, text: '8080', expectedType: 'value' },
      ]
    );

    test('deeply nested single line',
      'a {b {c value}}',
      [
        { line: 1, text: 'a', expectedType: 'key' },
        { line: 1, text: 'b', expectedType: 'key' },
        { line: 1, text: 'c', expectedType: 'key' },
        { line: 1, text: 'value', expectedType: 'value' },
      ]
    );

    test('sequence values',
      'numbers (1 2 3)',
      [
        { line: 1, text: 'numbers', expectedType: 'key' },
        { line: 1, text: '1', expectedType: 'value' },
        { line: 1, text: '2', expectedType: 'value' },
        { line: 1, text: '3', expectedType: 'value' },
      ]
    );

    test('tag as value',
      'timeout @duration(30s)',
      [
        { line: 1, text: 'timeout', expectedType: 'key' },
        { line: 1, text: '@duration', expectedType: 'tag' },
      ]
    );

    test('multiple entries multiline',
      `host localhost
port 8080
enabled true`,
      [
        { line: 1, text: 'host', expectedType: 'key' },
        { line: 1, text: 'localhost', expectedType: 'value' },
        { line: 2, text: 'port', expectedType: 'key' },
        { line: 2, text: '8080', expectedType: 'value' },
        { line: 3, text: 'enabled', expectedType: 'key' },
        { line: 3, text: 'true', expectedType: 'value' },
      ]
    );

    log('\n=== Debug: tokenize nested object ===');
    const nested = tokenize(`server {
    host localhost
    port 8080
}`);
    nested.forEach(line => {
      log(`Line ${line.line}: ${line.tokens.map(t => `"${t.text}"=${t.type}`).join(', ')}`);
    });
  </script>
</body>
</html>

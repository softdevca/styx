//! Go code generation from Styx schemas.

use facet_styx::SchemaFile;
use std::fmt::Write as _;
use std::path::Path;

mod error;
mod types;

pub use error::GenError;
use types::{GoType, TypeMapper};

/// Generate Go code from a Styx schema.
pub fn generate(schema: &SchemaFile, package_name: &str, output_dir: &str) -> Result<(), GenError> {
    let mut mapper = TypeMapper::new();

    // Collect all type definitions from the schema
    for (name_opt, schema_type) in &schema.schema {
        let type_name = match name_opt {
            Some(name) => name.clone(),
            None => "Config".to_string(), // Root type gets default name
        };
        mapper.register_type(&type_name, schema_type)?;
    }

    // Generate the main types file
    let types_code = generate_types_file(&mapper, package_name)?;
    let types_path = Path::new(output_dir).join("types.go");
    std::fs::write(&types_path, types_code)
        .map_err(|e| GenError::Io(format!("failed to write {}: {}", types_path.display(), e)))?;

    // Generate the validation file
    let validation_code = generate_validation_file(&mapper, package_name)?;
    let validation_path = Path::new(output_dir).join("validation.go");
    std::fs::write(&validation_path, validation_code).map_err(|e| {
        GenError::Io(format!(
            "failed to write {}: {}",
            validation_path.display(),
            e
        ))
    })?;

    // Generate the parsing helpers file
    let parse_code = generate_parse_file(&mapper, package_name, schema.meta.id.as_str())?;
    let parse_path = Path::new(output_dir).join("parse.go");
    std::fs::write(&parse_path, parse_code)
        .map_err(|e| GenError::Io(format!("failed to write {}: {}", parse_path.display(), e)))?;

    Ok(())
}

fn generate_types_file(mapper: &TypeMapper, package_name: &str) -> Result<String, GenError> {
    let mut out = String::new();

    // Package declaration
    writeln!(out, "// Code generated by styx gen go. DO NOT EDIT.")?;
    writeln!(out)?;
    writeln!(out, "package {}", package_name)?;
    writeln!(out)?;

    // Generate type definitions
    for (name, go_type) in mapper.types() {
        generate_type_definition(&mut out, name, go_type)?;
        writeln!(out)?;
    }

    Ok(out)
}

fn generate_type_definition(
    out: &mut String,
    name: &str,
    go_type: &GoType,
) -> Result<(), GenError> {
    match go_type {
        GoType::Struct { fields, doc } => {
            if let Some(doc) = doc {
                for line in doc.lines() {
                    writeln!(out, "// {}", line)?;
                }
            }
            writeln!(out, "type {} struct {{", name)?;
            for field in fields {
                if let Some(doc) = &field.doc {
                    for line in doc.lines() {
                        writeln!(out, "\t// {}", line)?;
                    }
                }
                let tags = format!(
                    "`json:\"{}{}\" styx:\"{}{}\"`",
                    field.json_name,
                    if field.optional { ",omitempty" } else { "" },
                    field.styx_name,
                    if field.optional { ",optional" } else { "" }
                );
                writeln!(out, "\t{} {} {}", field.go_name, field.type_name, tags)?;
            }
            writeln!(out, "}}")?;
        }
        GoType::Enum { variants, doc } => {
            if let Some(doc) = doc {
                for line in doc.lines() {
                    writeln!(out, "// {}", line)?;
                }
            }
            writeln!(out, "type {} string", name)?;
            writeln!(out)?;
            writeln!(out, "const (")?;
            for variant in variants {
                let const_name = format!("{}{}", name, to_pascal_case(&variant.name));
                if let Some(doc) = &variant.doc {
                    for line in doc.lines() {
                        writeln!(out, "\t// {}", line)?;
                    }
                }
                writeln!(out, "\t{} {} = \"{}\"", const_name, name, variant.name)?;
            }
            writeln!(out, ")")?;
        }
        _ => {}
    }
    Ok(())
}

fn generate_validation_file(mapper: &TypeMapper, package_name: &str) -> Result<String, GenError> {
    let mut out = String::new();

    writeln!(out, "// Code generated by styx gen go. DO NOT EDIT.")?;
    writeln!(out)?;
    writeln!(out, "package {}", package_name)?;
    writeln!(out)?;
    writeln!(out, "import (")?;
    writeln!(out, "\t\"fmt\"")?;
    writeln!(out, "\t\"strings\"")?;
    writeln!(out, ")")?;
    writeln!(out)?;

    // ValidationError type
    writeln!(out, "// ValidationError represents a validation failure.")?;
    writeln!(out, "type ValidationError struct {{")?;
    writeln!(out, "\tField   string")?;
    writeln!(out, "\tMessage string")?;
    writeln!(out, "}}")?;
    writeln!(out)?;
    writeln!(out, "func (e *ValidationError) Error() string {{")?;
    writeln!(out, "\treturn fmt.Sprintf(\"%s: %s\", e.Field, e.Message)")?;
    writeln!(out, "}}")?;
    writeln!(out)?;

    // ValidationErrors type
    writeln!(
        out,
        "// ValidationErrors represents multiple validation failures."
    )?;
    writeln!(out, "type ValidationErrors []*ValidationError")?;
    writeln!(out)?;
    writeln!(out, "func (e ValidationErrors) Error() string {{")?;
    writeln!(out, "\tif len(e) == 0 {{")?;
    writeln!(out, "\t\treturn \"no validation errors\"")?;
    writeln!(out, "\t}}")?;
    writeln!(out, "\tif len(e) == 1 {{")?;
    writeln!(out, "\t\treturn e[0].Error()")?;
    writeln!(out, "\t}}")?;
    writeln!(out, "\tvar msgs []string")?;
    writeln!(out, "\tfor _, err := range e {{")?;
    writeln!(out, "\t\tmsgs = append(msgs, err.Error())")?;
    writeln!(out, "\t}}")?;
    writeln!(
        out,
        "\treturn fmt.Sprintf(\"%d validation errors: %s\", len(e), strings.Join(msgs, \"; \"))"
    )?;
    writeln!(out, "}}")?;
    writeln!(out)?;

    // Generate validation functions for each type
    for (name, go_type) in mapper.types() {
        if let GoType::Struct { fields, .. } = go_type {
            generate_validation_function(&mut out, name, fields)?;
            writeln!(out)?;
        }
    }

    Ok(out)
}

fn generate_validation_function(
    out: &mut String,
    type_name: &str,
    fields: &[types::StructField],
) -> Result<(), GenError> {
    writeln!(out, "// Validate validates the {} instance.", type_name)?;
    writeln!(out, "func (v *{}) Validate() error {{", type_name)?;
    writeln!(out, "\tvar errs ValidationErrors")?;
    writeln!(out)?;

    for field in fields {
        // Check required fields
        if !field.optional && field.type_name.starts_with('*') {
            writeln!(out, "\tif v.{} == nil {{", field.go_name)?;
            writeln!(out, "\t\terrs = append(errs, &ValidationError{{")?;
            writeln!(out, "\t\t\tField:   \"{}\",", field.styx_name)?;
            writeln!(out, "\t\t\tMessage: \"required field is missing\",")?;
            writeln!(out, "\t\t}})")?;
            writeln!(out, "\t}}")?;
        }

        // Validate constraints
        if let Some(constraints) = &field.constraints {
            if field.optional {
                writeln!(out, "\tif v.{} != nil {{", field.go_name)?;
            }

            // String constraints
            if let Some(min_len) = constraints.min_length {
                let deref = if field.type_name.starts_with('*') {
                    "*"
                } else {
                    ""
                };
                writeln!(
                    out,
                    "\t\tif len({}v.{}) < {} {{",
                    deref, field.go_name, min_len
                )?;
                writeln!(out, "\t\t\terrs = append(errs, &ValidationError{{")?;
                writeln!(out, "\t\t\t\tField:   \"{}\",", field.styx_name)?;
                writeln!(
                    out,
                    "\t\t\t\tMessage: fmt.Sprintf(\"length must be at least {}\", {}),",
                    min_len, min_len
                )?;
                writeln!(out, "\t\t\t}})")?;
                writeln!(out, "\t\t}}")?;
            }

            if let Some(max_len) = constraints.max_length {
                let deref = if field.type_name.starts_with('*') {
                    "*"
                } else {
                    ""
                };
                writeln!(
                    out,
                    "\t\tif len({}v.{}) > {} {{",
                    deref, field.go_name, max_len
                )?;
                writeln!(out, "\t\t\terrs = append(errs, &ValidationError{{")?;
                writeln!(out, "\t\t\t\tField:   \"{}\",", field.styx_name)?;
                writeln!(
                    out,
                    "\t\t\t\tMessage: fmt.Sprintf(\"length must be at most {}\", {}),",
                    max_len, max_len
                )?;
                writeln!(out, "\t\t\t}})")?;
                writeln!(out, "\t\t}}")?;
            }

            // Integer constraints
            if let Some(min) = constraints.min_int {
                let deref = if field.type_name.starts_with('*') {
                    "*"
                } else {
                    ""
                };
                writeln!(out, "\t\tif {}v.{} < {} {{", deref, field.go_name, min)?;
                writeln!(out, "\t\t\terrs = append(errs, &ValidationError{{")?;
                writeln!(out, "\t\t\t\tField:   \"{}\",", field.styx_name)?;
                writeln!(
                    out,
                    "\t\t\t\tMessage: fmt.Sprintf(\"must be at least {}\", {}),",
                    min, min
                )?;
                writeln!(out, "\t\t\t}})")?;
                writeln!(out, "\t\t}}")?;
            }

            if let Some(max) = constraints.max_int {
                let deref = if field.type_name.starts_with('*') {
                    "*"
                } else {
                    ""
                };
                writeln!(out, "\t\tif {}v.{} > {} {{", deref, field.go_name, max)?;
                writeln!(out, "\t\t\terrs = append(errs, &ValidationError{{")?;
                writeln!(out, "\t\t\t\tField:   \"{}\",", field.styx_name)?;
                writeln!(
                    out,
                    "\t\t\t\tMessage: fmt.Sprintf(\"must be at most {}\", {}),",
                    max, max
                )?;
                writeln!(out, "\t\t\t}})")?;
                writeln!(out, "\t\t}}")?;
            }

            // Float constraints
            if let Some(min) = constraints.min_float {
                let deref = if field.type_name.starts_with('*') {
                    "*"
                } else {
                    ""
                };
                writeln!(out, "\t\tif {}v.{} < {} {{", deref, field.go_name, min)?;
                writeln!(out, "\t\t\terrs = append(errs, &ValidationError{{")?;
                writeln!(out, "\t\t\t\tField:   \"{}\",", field.styx_name)?;
                writeln!(
                    out,
                    "\t\t\t\tMessage: fmt.Sprintf(\"must be at least {}\", {}),",
                    min, min
                )?;
                writeln!(out, "\t\t\t}})")?;
                writeln!(out, "\t\t}}")?;
            }

            if let Some(max) = constraints.max_float {
                let deref = if field.type_name.starts_with('*') {
                    "*"
                } else {
                    ""
                };
                writeln!(out, "\t\tif {}v.{} > {} {{", deref, field.go_name, max)?;
                writeln!(out, "\t\t\terrs = append(errs, &ValidationError{{")?;
                writeln!(out, "\t\t\t\tField:   \"{}\",", field.styx_name)?;
                writeln!(
                    out,
                    "\t\t\t\tMessage: fmt.Sprintf(\"must be at most {}\", {}),",
                    max, max
                )?;
                writeln!(out, "\t\t\t}})")?;
                writeln!(out, "\t\t}}")?;
            }

            if field.optional {
                writeln!(out, "\t}}")?;
            }
        }
    }

    writeln!(out)?;
    writeln!(out, "\tif len(errs) > 0 {{")?;
    writeln!(out, "\t\treturn errs")?;
    writeln!(out, "\t}}")?;
    writeln!(out, "\treturn nil")?;
    writeln!(out, "}}")?;

    Ok(())
}

fn generate_parse_file(
    mapper: &TypeMapper,
    package_name: &str,
    _schema_id: &str,
) -> Result<String, GenError> {
    let mut out = String::new();

    writeln!(out, "// Code generated by styx gen go. DO NOT EDIT.")?;
    writeln!(out)?;
    writeln!(out, "package {}", package_name)?;
    writeln!(out)?;
    writeln!(out, "import (")?;
    writeln!(out, "\t\"os\"")?;
    writeln!(out)?;
    writeln!(
        out,
        "\tstyx \"github.com/bearcove/styx/implementations/styx-go\""
    )?;
    writeln!(out, ")")?;
    writeln!(out)?;

    // Find the root type (if any)
    let root_type = mapper.types().iter().find_map(|(name, go_type)| {
        if matches!(go_type, GoType::Struct { .. }) {
            Some(name.as_str())
        } else {
            None
        }
    });

    if let Some(root_type) = root_type {
        // LoadFromFile helper
        writeln!(
            out,
            "// LoadFromFile loads and validates a {} from a .styx file.",
            root_type
        )?;
        writeln!(
            out,
            "func LoadFromFile(path string) (*{}, error) {{",
            root_type
        )?;
        writeln!(out, "\tdata, err := os.ReadFile(path)")?;
        writeln!(out, "\tif err != nil {{")?;
        writeln!(out, "\t\treturn nil, err")?;
        writeln!(out, "\t}}")?;
        writeln!(out, "\treturn Parse(string(data))")?;
        writeln!(out, "}}")?;
        writeln!(out)?;

        // Parse helper
        writeln!(
            out,
            "// Parse parses and validates a {} from a .styx string.",
            root_type
        )?;
        writeln!(out, "func Parse(source string) (*{}, error) {{", root_type)?;
        writeln!(out, "\tdoc, err := styx.Parse(source)")?;
        writeln!(out, "\tif err != nil {{")?;
        writeln!(out, "\t\treturn nil, err")?;
        writeln!(out, "\t}}")?;
        writeln!(out)?;
        writeln!(out, "\t// TODO: Map styx.Document to {} struct", root_type)?;
        writeln!(
            out,
            "\t// This requires implementing a mapper from styx values to Go types"
        )?;
        writeln!(out, "\tvar config {}", root_type)?;
        writeln!(out, "\t_ = doc // Use doc to populate config")?;
        writeln!(out)?;
        writeln!(out, "\t// Validate the parsed config")?;
        writeln!(out, "\tif err := config.Validate(); err != nil {{")?;
        writeln!(out, "\t\treturn nil, err")?;
        writeln!(out, "\t}}")?;
        writeln!(out)?;
        writeln!(out, "\treturn &config, nil")?;
        writeln!(out, "}}")?;
    }

    Ok(out)
}

fn to_pascal_case(s: &str) -> String {
    s.split(['_', '-'])
        .filter(|s| !s.is_empty())
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

impl From<std::fmt::Error> for GenError {
    fn from(_: std::fmt::Error) -> Self {
        GenError::Format("formatting error".into())
    }
}
